\documentclass[11pt]{report}
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\title{TFE4170 Assignment 4}
\author{Ole Magnus Ruud \\ Vegar K\aa sli}
\begin{document}

\maketitle
\clearpage

\section*{Introduction}


\section*{Task 1}
We divided the memory layout into two part: A static part containing all the
status words for the different modules and freeloc, and a circular buffer for
all the packets. 
\\
\\Addresses in FastMem (byte-indexed)
\\0x000 Control status word
\\0x004 freeloc
\\0x008 - 0x044 Adapter/Button status words
\\0x048 Start of circular buffer
\\0xFFF End of circular buffer

\section*{Task 2}

The adapter functionality was split into two threads, one listening for
changes to the button status in memory, and one responding to button pushes.
The adapter had to implement the bus interface from the previous assignment
to be compatible with the buttons. The functionality of the inherited push
method was reduced to notifying the button push thread(pushListen).

The thread waiting for changes to the status in memory(main) simply reads the 
corresponding status location at set intervals, and calls the light function
of the button whenever it is necessary. It does not start reading from memory
until notified by pushListen, as the light will never be lit before the button
has been pushed.

The pushListen thread generates a new packet when notified, and uses the send
method to write it to the bus. It also calls a bounce method that generates 
one or more releasepackets (task 5).

The send method is pretty much implemented as specified in the assignment text.
The ring buffer pointer is checked to be suitable to the packet size and set to 
the base buffer address if the end is reached. First the basic packet is sent, 
and in case of a bigger packet (task 5) the rest is sent in a separate burst.

  



\section*{Task 3}
The basic functionality of the control is kept the same as in exercise two, but
the communication with the other modules had to be adapted to fit the new bus
model.\\
\\Control checks its status word for a non-zero value, and if it reads one, it
will split it into two parts: The address in FastMem for the packet, and the
identity of the button/adapter from which the packet originated. It will then
read from FastMem, at the location pointed to in the status word.\\
\\If the packet in FastMem appears to be valid, the Control module will see if
the button that was pressed, is in fact the correct button in the sequence. If
it was correct, it will advance its internal counter to the next button, and
write to that button's status word in FastMem; setting it to a non-zero value.
If it was not the correct button, it will write to all the previously pressed
buttons' status words, setting them to zero.\\
\\Finally it will set its status word to zero. It then sleeps for a short 
while, before it again checks to see if its status word is set to any non-zero 
value.

\section*{Task 4}



\end{document}
